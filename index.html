<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }
        #gameContainer {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 0 40px rgba(100, 200, 255, 0.1);
            border: 2px solid rgba(100, 200, 255, 0.3);
            position: relative;
            width: 650px;
        }
        #instructions {
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.15), rgba(100, 100, 255, 0.15));
            padding: 12px;
            border-radius: 15px;
            margin-bottom: 12px;
            text-align: center;
            border: 2px solid rgba(0, 200, 255, 0.3);
        }
        #instructions h2 {
            margin-bottom: 8px;
            font-size: 20px;
            font-weight: 900;
            text-transform: uppercase;
            background: linear-gradient(45deg, #00d4ff, #7b68ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .instruction-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-top: 8px; }
        .instruction-item { background: rgba(0, 0, 0, 0.4); padding: 8px; border-radius: 6px; font-size: 11px; }
        .instruction-item strong { color: #00d4ff; display: block; font-size: 10px; text-transform: uppercase; }
        #gameInfo { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 12px; }
        .stat-box { background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(50, 50, 80, 0.4)); padding: 10px; border-radius: 10px; text-align: center; border: 2px solid rgba(100, 200, 255, 0.3); }
        .stat-label { font-size: 10px; text-transform: uppercase; color: rgba(255, 255, 255, 0.8); margin-bottom: 5px; font-weight: 700; }
        .stat-value { font-size: 24px; font-weight: 900; background: linear-gradient(45deg, #00d4ff, #ffffff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .coins-value { background: linear-gradient(45deg, #ffd700, #ffed4e); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .lives-value { background: linear-gradient(45deg, #ff3366, #ff6b9d); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        #gameCanvas { border: 3px solid rgba(0, 200, 255, 0.5); border-radius: 10px; display: block; background: #0a0a15; }
        button {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 900;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 15px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            width: 100%;
        }
        #cashOutBtn { background: linear-gradient(135deg, #00ff88, #00cc66); }
        #gameOver, #levelComplete { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(10, 10, 30, 0.98), rgba(30, 30, 60, 0.98)); padding: 40px; border-radius: 20px; text-align: center; border: 3px solid #00d4ff; min-width: 350px; }
        #gameOver h2, #levelComplete h2 { font-size: 42px; margin-bottom: 20px; font-weight: 900; text-transform: uppercase; background: linear-gradient(45deg, #00d4ff, #7b68ee); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .score-display { font-size: 32px; font-weight: 900; background: linear-gradient(45deg, #ffd700, #ffed4e); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 10px 0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">
            <h2>MAZE RUNNER</h2>
            <div class="instruction-grid">
                <div class="instruction-item"><strong>Controls</strong>Arrow Keys / WASD</div>
                <div class="instruction-item"><strong>Mission</strong>Collect coins & exit</div>
                <div class="instruction-item"><strong>Danger</strong>Avoid obstacles</div>
                <div class="instruction-item"><strong>Levels</strong>100 levels</div>
            </div>
        </div>
        <div id="gameInfo">
            <div class="stat-box"><div class="stat-label">Level</div><div class="stat-value" id="level">1</div></div>
            <div class="stat-box"><div class="stat-label">Cash</div><div class="stat-value" id="score">$0.00</div></div>
            <div class="stat-box"><div class="stat-label">Lives</div><div class="stat-value lives-value" id="lives">3</div></div>
            <div class="stat-box"><div class="stat-label">Coins</div><div class="stat-value coins-value"><span id="coinsCollected">0</span>/<span id="totalCoins">0</span></div></div>
        </div>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <button id="cashOutBtn" onclick="cashOut()">ðŸ’° Cash Out</button>
        <div id="gameOver"><h2>Game Over</h2><p>FINAL CASH</p><div class="score-display" id="finalScore">$0.00</div><button onclick="restartGame()">Play Again</button></div>
        <div id="levelComplete"><h2>Level Clear!</h2><p>CURRENT CASH</p><div class="score-display" id="levelScore">$0.00</div><button onclick="nextLevel()">Next Level</button></div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameState = { level: 1, cash: 0, lives: 3, player: { x: 90, y: 90, size: 30 }, coins: [], obstacles: [], walls: [], powerup: null, exit: null, coinsCollected: 0, totalCoins: 0, cellSize: 60, isGameOver: false, isPaused: false, invincible: false, invincibleTimer: 0 };
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault(); });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(f, d, t = 'sine') { try { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.frequency.value = f; o.type = t; g.gain.setValueAtTime(0.3, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + d); o.start(); o.stop(audioCtx.currentTime + d); } catch(e) {} }
        function coinSound() { playSound(800, 0.1); setTimeout(() => playSound(1000, 0.1), 50); }
        function hitSound() { playSound(100, 0.3, 'sawtooth'); }
        function levelCompleteSound() { playSound(523, 0.15); setTimeout(() => playSound(659, 0.15), 150); }
        function powerupSound() { playSound(440, 0.1); setTimeout(() => playSound(880, 0.2), 100); }
        function gameOverSound() { playSound(400, 0.2); setTimeout(() => playSound(200, 0.4), 200); }
        function generateCoinValue() { const r = Math.random(); if (r < 0.55) return (Math.random() * 0.23 + 0.12); else if (r < 0.80) return (Math.random() * 0.29 + 0.36); else if (r < 0.93) return (Math.random() * 0.29 + 0.66); else return (Math.random() * 0.27 + 0.96); }
        function generateWalls(lv) { const walls = []; const cs = gameState.cellSize; const gw = Math.floor(canvas.width / cs); const gh = Math.floor(canvas.height / cs); for (let i = 0; i < gw; i++) { walls.push({ x: i * cs, y: 0, w: cs, h: cs }); walls.push({ x: i * cs, y: (gh - 1) * cs, w: cs, h: cs }); } for (let i = 1; i < gh - 1; i++) { walls.push({ x: 0, y: i * cs, w: cs, h: cs }); walls.push({ x: (gw - 1) * cs, y: i * cs, w: cs, h: cs }); } const iw = 3 + lv * 2; for (let i = 0; i < iw; i++) { const x = (2 + Math.floor(Math.random() * (gw - 4))) * cs; const y = (2 + Math.floor(Math.random() * (gh - 4))) * cs; const h = Math.random() > 0.5; const len = 1 + Math.floor(Math.random() * 2); for (let j = 0; j < len; j++) { if (h && x + j * cs < (gw - 2) * cs) walls.push({ x: x + j * cs, y: y, w: cs, h: cs }); else if (!h && y + j * cs < (gh - 2) * cs) walls.push({ x: x, y: y + j * cs, w: cs, h: cs }); } } return walls; }
        function collidesWithWall(x, y, size) { for (let wall of gameState.walls) { if (x + size/2 > wall.x && x - size/2 < wall.x + wall.w && y + size/2 > wall.y && y - size/2 < wall.y + wall.h) return true; } return false; }
        function initLevel(lv) { const cs = gameState.cellSize; gameState.coinsCollected = 0; gameState.isPaused = false; gameState.invincible = false; gameState.invincibleTimer = 0; gameState.walls = generateWalls(lv); const gw = Math.floor(canvas.width / cs); const gh = Math.floor(canvas.height / cs); gameState.player.x = cs * 1.5; gameState.player.y = cs * 1.5; gameState.coins = []; const cc = 4 + Math.floor(lv / 2); for (let i = 0; i < cc; i++) { let placed = false, att = 0; while (!placed && att < 100) { const x = cs * (2 + Math.random() * (gw - 4)); const y = cs * (2 + Math.random() * (gh - 4)); if (!collidesWithWall(x, y, 20)) { gameState.coins.push({ x: x, y: y, size: 18, value: generateCoinValue() }); placed = true; } att++; } } gameState.totalCoins = gameState.coins.length; gameState.obstacles = []; const oc = Math.min(lv + 1, 15); for (let i = 0; i < oc; i++) { let placed = false, att = 0; while (!placed && att < 100) { const x = cs * (2 + Math.random() * (gw - 4)); const y = cs * (2 + Math.random() * (gh - 4)); if (!collidesWithWall(x, y, 35)) { gameState.obstacles.push({ x: x, y: y, size: 35, dx: (Math.random() - 0.5) * (2 + lv * 0.15), dy: (Math.random() - 0.5) * (2 + lv * 0.15) }); placed = true; } att++; } } gameState.powerup = null; if (Math.random() < 0.3) { let placed = false, att = 0; while (!placed && att < 50) { const x = cs * (2 + Math.random() * (gw - 4)); const y = cs * (2 + Math.random() * (gh - 4)); if (!collidesWithWall(x, y, 20)) { gameState.powerup = { x: x, y: y, size: 20 }; placed = true; } att++; } } gameState.exit = { x: canvas.width - cs * 1.5, y: canvas.height - cs * 1.5, size: 40 }; updateUI(); }
        function updateUI() { document.getElementById('level').textContent = gameState.level; document.getElementById('score').textContent = '$' + gameState.cash.toFixed(2); document.getElementById('lives').textContent = gameState.lives; document.getElementById('coinsCollected').textContent = gameState.coinsCollected; document.getElementById('totalCoins').textContent = gameState.totalCoins; }
        function checkCollision(o1, o2) { const d = Math.sqrt((o1.x - o2.x) ** 2 + (o1.y - o2.y) ** 2); return d < (o1.size + o2.size) / 2; }
        function update() { if (gameState.isGameOver || gameState.isPaused) return; const p = gameState.player; if (gameState.invincible) { gameState.invincibleTimer--; if (gameState.invincibleTimer <= 0) gameState.invincible = false; } let mx = 0, my = 0; if (keys['arrowup'] || keys['w']) my -= 1; if (keys['arrowdown'] || keys['s']) my += 1; if (keys['arrowleft'] || keys['a']) mx -= 1; if (keys['arrowright'] || keys['d']) mx += 1; if (mx !== 0 && my !== 0) { mx *= 0.707; my *= 0.707; } const nx = p.x + mx * 4; const ny = p.y + my * 4; if (!collidesWithWall(nx, p.y, p.size)) p.x = nx; if (!collidesWithWall(p.x, ny, p.size)) p.y = ny; for (let i = gameState.coins.length - 1; i >= 0; i--) { if (checkCollision(p, gameState.coins[i])) { gameState.cash += gameState.coins[i].value; gameState.coins.splice(i, 1); gameState.coinsCollected++; coinSound(); updateUI(); } } if (gameState.powerup && checkCollision(p, gameState.powerup)) { gameState.powerup = null; gameState.invincible = true; gameState.invincibleTimer = 180; gameState.cash += 0.50; powerupSound(); updateUI(); } gameState.obstacles.forEach(obs => { const nx = obs.x + obs.dx; const ny = obs.y + obs.dy; if (collidesWithWall(nx, obs.y, obs.size)) obs.dx *= -1; else obs.x = nx; if (collidesWithWall(obs.x, ny, obs.size)) obs.dy *= -1; else obs.y = ny; if (!gameState.invincible && checkCollision(p, obs)) { gameState.lives--; hitSound(); updateUI(); if (gameState.lives <= 0) endGame(); else { p.x = gameState.cellSize * 1.5; p.y = gameState.cellSize * 1.5; } } }); if (gameState.coinsCollected >= gameState.totalCoins && checkCollision(p, gameState.exit)) completeLevel(); }
        function draw() { const g = ctx.createLinearGradient(0, 0, canvas.width, canvas.height); g.addColorStop(0, '#0a0a15'); g.addColorStop(1, '#1a1a2e'); ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(0, 200, 255, 0.05)'; ctx.lineWidth = 1; for (let i = 0; i < canvas.width; i += gameState.cellSize) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); } for (let i = 0; i < canvas.height; i += gameState.cellSize) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke(); } gameState.walls.forEach(w => { ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(w.x + 2, w.y + 2, w.w, w.h); const wg = ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y + w.h); wg.addColorStop(0, '#2a2a4a'); wg.addColorStop(1, '#1a1a2a'); ctx.fillStyle = wg; ctx.fillRect(w.x, w.y, w.w, w.h); ctx.strokeStyle = 'rgba(100, 100, 200, 0.3)'; ctx.lineWidth = 2; ctx.strokeRect(w.x, w.y, w.w, w.h); }); const e = gameState.exit; const pi = 0.5 + Math.sin(Date.now() / 300) * 0.5; ctx.save(); ctx.translate(e.x, e.y); if (gameState.coinsCollected >= gameState.totalCoins) { const rot = Date.now() / 1000; ctx.shadowBlur = 35 * pi; ctx.shadowColor = '#00ff00'; ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, e.size/2 + 2, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, e.size/2 - 4, 0, Math.PI * 2); ctx.stroke(); const eg = ctx.createRadialGradient(0, 0, 0, 0, 0, e.size/2 - 8); eg.addColorStop(0, 'rgba(0, 255, 100, 0.6)'); eg.addColorStop(0.5, 'rgba(0, 255, 0, 0.3)'); eg.addColorStop(1, 'rgba(0, 255, 0, 0.1)'); ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(0, 0, e.size/2 - 8, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(0, 255, 100, 0.6)'; ctx.lineWidth = 2; for (let i = 0; i < 3; i++) { ctx.beginPath(); for (let a = 0; a < Math.PI * 2; a += 0.1) { const r = (e.size/2 - 12) * (0.3 + (a / (Math.PI * 2)) * 0.7); const x = Math.cos(a + rot + i * 2) * r; const y = Math.sin(a + rot + i * 2) * r; if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.stroke(); } } else { ctx.shadowBlur = 12; ctx.shadowColor = '#666'; ctx.strokeStyle = '#555'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, e.size/2 + 2, 0, Math.PI * 2); ctx.stroke(); ctx.strokeStyle = '#777'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, e.size/2 - 4, 0, Math.PI * 2); ctx.stroke(); const eg = ctx.createRadialGradient(0, 0, 0, 0, 0, e.size/2 - 8); eg.addColorStop(0, 'rgba(120, 120, 120, 0.4)'); eg.addColorStop(1, 'rgba(80, 80, 80, 0.2)'); ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(0, 0, e.size/2 - 8, 0, Math.PI * 2); ctx.fill(); } ctx.shadowBlur = 0; ctx.restore(); gameState.coins.forEach(c => { ctx.save(); ctx.translate(c.x, c.y); ctx.shadowBlur = 15; ctx.shadowColor = '#ffd700'; ctx.fillStyle = '#b8860b'; ctx.beginPath(); ctx.arc(0, 0, c.size, 0, Math.PI * 2); ctx.fill(); const cg = ctx.createRadialGradient(-4, -4, 0, 0, 0, c.size); cg.addColorStop(0, '#fff9e6'); cg.addColorStop(0.3, '#ffd700'); cg.addColorStop(0.7, '#ffb700'); cg.addColorStop(1, '#cc9900'); ctx.fillStyle = cg; ctx.beginPath(); ctx.arc(0, 0, c.size - 2, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(184, 134, 11, 0.8)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, c.size - 6, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0; ctx.fillStyle = '#b8860b'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', 0, 1); ctx.restore(); ctx.save(); ctx.shadowBlur = 8; ctx.shadowColor = 'rgba(0, 0, 0, 0.8)'; ctx.fillStyle = '#ffd700'; ctx.font = 'bold 12px Orbitron, Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; ctx.fillText('$' + c.value.toFixed(2), c.x, c.y - c.size - 5); ctx.shadowBlur = 0; ctx.restore(); }); if (gameState.powerup) { const pw = gameState.powerup; ctx.save(); ctx.translate(pw.x, pw.y); const pp = 1 + Math.sin(Date.now() / 200) * 0.2; ctx.shadowBlur = 20; ctx.shadowColor = '#ff00ff'; ctx.fillStyle = '#ff00ff'; ctx.beginPath(); for (let i = 0; i < 8; i++) { const a = (i * Math.PI) / 4; const r = (i % 2 === 0) ? pw.size * pp : pw.size * 0.5 * pp; const x = Math.cos(a) * r; const y = Math.sin(a) * r; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); } ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0; ctx.restore(); } gameState.obstacles.forEach((o, i) => { const p = 1 + Math.sin(Date.now() / 200 + i) * 0.1; ctx.shadowBlur = 20; ctx.shadowColor = '#ff0000'; const og = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.size/2 * p); og.addColorStop(0, '#ff6666'); og.addColorStop(1, '#cc0000'); ctx.fillStyle = og; ctx.beginPath(); ctx.arc(o.x, o.y, o.size/2 * p, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('ðŸ’€', o.x, o.y); }); const pl = gameState.player; const gp = 15 + Math.sin(Date.now() / 200) * 5; if (gameState.invincible) { const h = (Date.now() / 10) % 360; ctx.shadowBlur = gp * 2; ctx.shadowColor = 'hsl(' + h + ', 100%, 50%)'; const pg = ctx.createRadialGradient(pl.x, pl.y, 0, pl.x, pl.y, pl.size/2); pg.addColorStop(0, 'hsl(' + h + ', 100%, 80%)'); pg.addColorStop(1, 'hsl(' + h + ', 100%, 50%)'); ctx.fillStyle = pg; } else { ctx.shadowBlur = gp; ctx.shadowColor = '#00ccff'; const pg = ctx.createRadialGradient(pl.x, pl.y, 0, pl.x, pl.y, pl.size/2); pg.addColorStop(0, '#66ddff'); pg.addColorStop(1, '#0099cc'); ctx.fillStyle = pg; } ctx.beginPath(); ctx.arc(pl.x, pl.y, pl.size/2, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(pl.x - 5, pl.y - 3, 3, 0, Math.PI * 2); ctx.arc(pl.x + 5, pl.y - 3, 3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(pl.x - 5, pl.y - 3, 1.5, 0, Math.PI * 2); ctx.arc(pl.x + 5, pl.y - 3, 1.5, 0, Math.PI * 2); ctx.fill(); }
        function completeLevel() { gameState.isPaused = true; levelCompleteSound(); gameState.cash += gameState.level * 0.50; document.getElementById('levelScore').textContent = '$' + gameState.cash.toFixed(2); document.getElementById('levelComplete').style.display = 'block'; }
        function nextLevel() { document.getElementById('levelComplete').style.display = 'none'; gameState.level++; if (gameState.level > 100) { alert('CONGRATULATIONS! You completed all 100 levels! Final Cash: $' + gameState.cash.toFixed(2)); restartGame(); } else { initLevel(gameState.level); } }
        function endGame() { gameState.isGameOver = true; gameOverSound(); document.getElementById('finalScore').textContent = '$' + gameState.cash.toFixed(2); document.getElementById('gameOver').style.display = 'block'; }
        function restartGame() { document.getElementById('gameOver').style.display = 'none'; document.getElementById('levelComplete').style.display = 'none'; gameState.level = 1; gameState.cash = 0; gameState.lives = 3; gameState.isGameOver = false; initLevel(1); }
        function cashOut() { if (gameState.cash > 0) { alert('ðŸ’° CASH OUT!\n\nYou cashed out: $' + gameState.cash.toFixed(2) + '\nLevel: ' + gameState.level); gameState.level = 1; gameState.cash = 0; gameState.lives = 3; gameState.isGameOver = false; initLevel(1); } else { alert('No cash to withdraw!'); } }
        function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
        initLevel(1); gameLoop();
    </script>
</body>
</html>
